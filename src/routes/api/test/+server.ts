import { error, json } from "@sveltejs/kit";
import type { RequestHandler } from "./$types";
import PreviewComponent from "$lib/components/Preview.svelte";
import { render } from "svelte/server";
import { minify } from "html-minifier";
import { PurgeCSS } from "purgecss";
import { attempt } from "$lib/utils/attempt";
import previewStylesCSS from "../../../styles/generated/preview-styles.css?raw";

/**
 * Comprehensive cleanup function for generated HTML
 * - Removes Svelte scoped classes (s-<hash>)
 * - Removes empty class attributes
 * - Cleans up multiple spaces
 * - Removes Svelte event handlers (onload/onerror)
 * - Normalizes whitespace between elements
 * 
 * @param {string} html - The HTML string to clean
 * @returns {string} Cleaned HTML string
 */
function stripSvelteArtifacts(html: string): string {
  return html
    .replace(/\s*s-[a-zA-Z0-9_-]+/g, "")
    .replace(/\s*onload="this\.__e=event"\s*/g, " ")
    .replace(/\s*onerror="this\.__e=event"\s*/g, " ")
    .replace(/\s*class=(["'])\1\s*/g, " ")
    .replace(/\s+/g, " ")
    .replace(/>\s+</g, "><")
    .trim();
}

export const POST: RequestHandler = async ({ request }) => {
  // Get form data
  const [formDataError, data] = await attempt(request.formData());
  if (formDataError) {
    throw error(400, "Invalid form data");
  }

  const propsString = data.get("props")?.toString() ?? "{}";
  
  // Validate JSON props
  const [parseError, props] = await attempt(Promise.resolve(JSON.parse(propsString)));
  if (parseError) {
    throw error(400, "Invalid JSON in props parameter");
  }

  // Render the component (this is synchronous and unlikely to fail)
  const result = render(PreviewComponent, { props });
  const rawHTML = stripSvelteArtifacts(result.body);

  // Minify HTML (this is synchronous and unlikely to fail with valid input)
  const minifiedHTML = minify(rawHTML, {
    includeAutoGeneratedTags: true,
    removeAttributeQuotes: false,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    sortClassName: true,
    collapseWhitespace: true
  });

  // Create temporary HTML for PurgeCSS
  const tempHTML = `<style>${previewStylesCSS}</style><main class="page">${minifiedHTML}</main>`;

  console.log("CSS length before purge:", previewStylesCSS.length);

  // Purge unused CSS (this is async and can fail)
  const [purgeCSSError, purgeCSSResult] = await attempt(
    new PurgeCSS().purge({
      content: [{ raw: tempHTML, extension: "html" }],
      css: [{ raw: previewStylesCSS }],
      // Remove the broad safelists to be more aggressive
      safelist: [],
      // Only keep CSS custom properties that are actually used
      variables: false,
      keyframes: false,
      fontFace: false
    })
  );

  if (purgeCSSError) {
    console.error("PurgeCSS error:", purgeCSSError);
    throw error(500, "Failed to purge CSS");
  }

  console.log("CSS length after purge:", purgeCSSResult && purgeCSSResult[0].css.length);

  // Generate final HTML
  const finalHTML = `<style>${purgeCSSResult[0].css}</style><main class="page">${minifiedHTML}</main>`;
  
  // Return clean JSON response
  return json({
    success: true,
    html: finalHTML
  });
}